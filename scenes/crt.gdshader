// CRT Shader by Harrison Allen
// V2

shader_type canvas_item;

/**
	The input texture that will have the CRT effect applied to it.
	Scanline count will be determined by this texture's height. 
	You'll need to use a texture that's roughly screen height / 2.25
	(for instance 240 on a 1080 monitor or 480 on a 4k monitor)
	Else The scanlines won't properly resolve and you're get moir√© patters.
	*/
uniform sampler2D tex: filter_linear;


/**
	Set the type of mask this CRT will have.
	Dots or aperture grille work great on 1080 monitors, while wide might be
	the better choice for 4K.
	*/
uniform int mask_type : hint_enum(
	"Dots:1", "Aperture Grille:2",
	"Wide Grille:3", "Slot Mask:4", "Null:0") = 1;

uniform float curve : hint_range(0, 1) = 0.5;

/**
	Controlls how sharp the image is. Low values are fun with dithering, but a
	value of 0.5 will destroy high frequency details, and render small text
	illegible, so use with care.
	*/
uniform float sharpness : hint_range(0.5, 1.0) = 0.6666666666666666666666666667;

/**
	Use to offset color channels from each other.
	*/
uniform float color_offset : hint_range(-0.5, 0.5) = 0.0;

/**
	Reduce to perserve scanlines and phosphor details in highlights at the cost
	of overall brightness
	*/
uniform float brightness : hint_range(0, 1) = 1.0;

/**
	This should be the input texture's height divided by width
	*/
uniform float aspect : hint_range(0.5, 1.0) = 0.75;

uniform float min_scanline_thickness : hint_range(0.25, 1.0) = 0.5;

vec2 warp(vec2 uv, float _aspect, float _curve)
{
	// Centralizes coordinates (0 is in the middle)
	uv -= 0.5;

	uv.x /= _aspect;

	// Squared distance from the middle
	float warping = dot(uv, uv) * _curve;

	// Compensate for shrinking
	warping -= _curve * 0.25;

	// Warp the coordinates
	uv /= 1.0 - warping;

	uv.x *= _aspect;

	// Decentralize the coordinates
	uv += 0.5;

	return uv;
}

vec3 linear_to_srgb(vec3 col)
{
	bvec3 cutoff = lessThan(col, vec3(0.0031308));
	vec3 higher = vec3(1.055) * pow(col, vec3(1.0 / 2.4)) - vec3(0.055);
	vec3 lower = col * 12.92;

	return mix(higher, lower, cutoff);
}

vec3 srgb_to_linear(vec3 col)
{
	bvec3 cutoff = lessThan(col, vec3(0.04045));
	vec3 higher = pow((col + vec3(0.055)) / 1.055, vec3(2.4));
	vec3 lower = col / 12.92;

	return mix(higher, lower, cutoff);
}

// Get scanlines from coordinates (returns in linear color)
vec3 scanlines(vec2 uv)
{
	// Set coordinates to match texture demisions
	uv *= vec2(textureSize(tex, 0));

	// Vertical coordinate scanline samples
	int y = int(floor(uv.y - 0.5));

	float x = floor(uv.x);

	// Horizontal coordinates for the texture samples
	float ax = x - 2.0;
	float bx = x - 1.0;
	float cx = x;
	float dx = x + 1.0;
	float ex = x + 2.0;

	// Sample the texture at various points
	vec3 upper_a = texelFetch(tex, ivec2(int(ax), y), 0).rgb;
	vec3 upper_b = texelFetch(tex, ivec2(int(bx), y), 0).rgb;
	vec3 upper_c = texelFetch(tex, ivec2(int(cx), y), 0).rgb;
	vec3 upper_d = texelFetch(tex, ivec2(int(dx), y), 0).rgb;
	vec3 upper_e = texelFetch(tex, ivec2(int(ex), y), 0).rgb;
	
	// Adjust the vertical coordinate for the lower scanline
	y += 1;

	// Sample the texture at various points
	vec3 lower_a = texelFetch(tex, ivec2(int(ax), y), 0).rgb;
	vec3 lower_b = texelFetch(tex, ivec2(int(bx), y), 0).rgb;
	vec3 lower_c = texelFetch(tex, ivec2(int(cx), y), 0).rgb;
	vec3 lower_d = texelFetch(tex, ivec2(int(dx), y), 0).rgb;
	vec3 lower_e = texelFetch(tex, ivec2(int(ex), y), 0).rgb;
	
	// Convert to linear color
	upper_a = srgb_to_linear(upper_a);
	upper_b = srgb_to_linear(upper_b);
	upper_c = srgb_to_linear(upper_c);
	upper_d = srgb_to_linear(upper_d);
	upper_e = srgb_to_linear(upper_e);

	lower_a = srgb_to_linear(lower_a);
	lower_b = srgb_to_linear(lower_b);
	lower_c = srgb_to_linear(lower_c);
	lower_d = srgb_to_linear(lower_d);
	lower_e = srgb_to_linear(lower_e);

	// The x coordinates of the closest
	vec3 beam = vec3(uv.x - 0.5);
	beam.r -= color_offset;
	beam.b += color_offset;

	// Calculate weights
	vec3 weight_a = smoothstep(1, 0, (beam - ax) * sharpness);
	vec3 weight_b = smoothstep(1, 0, (beam - bx) * sharpness);
	vec3 weight_c = smoothstep(1, 0, abs(beam - cx) * sharpness);
	vec3 weight_d = smoothstep(1, 0, (dx - beam) * sharpness);
	vec3 weight_e = smoothstep(1, 0, (ex - beam) * sharpness);
	
	// Mix samples into the upper scanline color
	vec3 upper_col = vec3(
		upper_a * weight_a +
		upper_b * weight_b +
		upper_c * weight_c +
		upper_d * weight_d +
		upper_e * weight_e
	);
	
	// Mix samples into the lower scanline color
	vec3 lower_col = vec3(
		lower_a * weight_a +
		lower_b * weight_b +
		lower_c * weight_c +
		lower_d * weight_d +
		lower_e * weight_e
	);

	vec3 weight_scaler = vec3(1.0) / (weight_a + weight_b + weight_c + weight_d + weight_e);

	// Normalize weight
	upper_col *= weight_scaler;
	lower_col *= weight_scaler;

	// Scanline size (and roughly the apperent brightness of this line)
	vec3 upper_thickness = mix(vec3(min_scanline_thickness), vec3(1.0), upper_col);
	vec3 lower_thickness = mix(vec3(min_scanline_thickness), vec3(1.0), lower_col);
	
	// Vertical sawtooth wave used to generate scanlines
	float sawtooth = fract(uv.y + 0.5);

	vec3 upper_line = vec3(sawtooth) / upper_thickness;
	upper_line = smoothstep(1.0, 0.0, upper_line);

	vec3 lower_line = vec3(1.0 - sawtooth) / lower_thickness;
	lower_line = smoothstep(1.0, 0.0, lower_line);

	// Correct line brightness below min_scanline_thickness
	upper_line *= upper_col / upper_thickness;
	lower_line *= lower_col / lower_thickness;

	// Combine the upper and lower scanlines
	vec3 combined = upper_line + lower_line;

	// Calculate dim version
	vec3 dark_upper = smoothstep(min_scanline_thickness, 0.0, vec3(sawtooth));
	dark_upper *= upper_col;

	vec3 dark_lower = smoothstep(min_scanline_thickness, 0.0, vec3(1.0 - sawtooth));
	dark_lower *= lower_col;
	
	vec3 dark_combined = dark_upper + dark_lower;

	// Mix bright and dim
	return mix(dark_combined, combined, brightness);
}

vec4 grille(float fragcoord_x)
{
	const vec3 pat[] = {vec3(0,1,0), vec3(1,0,1)};
	
	return vec4(pat[int(fragcoord_x) % 2], 0.5);
}

vec4 grille_wide(float fragcoord_x)
{
	const vec3 pat[] = {vec3(1,0,0), vec3(0,1,0), vec3(0,0,1), vec3(0,0,0)};
	
	return vec4(pat[int(fragcoord_x) % 4], 0.25);
}

vec4 dots(vec2 fragcoord)
{
	const vec3 pat[] = {vec3(1,0,0), vec3(0,1,0), vec3(0,0,1), vec3(0,0,0)};
	
	ivec2 icoords = ivec2(fragcoord);
	
	return vec4(pat[(icoords.y * 2 + icoords.x) % 4], 0.25);
}

vec4 slot_mask(vec2 fragcoord)
{
	const vec3 pat[] = {
		vec3(1,0,1), vec3(0,1,0), vec3(1,0,1), vec3(0,1,0),
		vec3(0,0,1), vec3(0,1,0), vec3(1,0,0), vec3(0,0,0),
		vec3(1,0,1), vec3(0,1,0), vec3(1,0,1), vec3(0,1,0),
		vec3(1,0,0), vec3(0,0,0), vec3(0,0,1), vec3(0,1,0)
	};
	
	ivec2 icoords = ivec2(fragcoord) % 4;
	
	return vec4(pat[icoords.y * 4 + icoords.x], 0.375);
}

vec4 generate_mask(vec2 fragcoord)
{
	switch (mask_type)
	{
		case 1:
			return dots(fragcoord);
		case 2:
			return grille(fragcoord.x);
		case 3:
			return grille_wide(fragcoord.x);
		case 4:
			return slot_mask(fragcoord);
		default:
			return vec4(1);
	}
}

// Add phosphor mask/grill
vec3 mask(vec3 linear_color, vec2 fragcoord)
{
	// Get the pattern for the mask. The W component equals avg. mask brightness
	vec4 mask = generate_mask(fragcoord);
	
	// How bright the color needs to be to maintain 100% brightness while masked
	vec3 target_color = linear_color / mask.w;

	// Target color limited to the 0 to 1 range.
	vec3 target_clamped = clamp(target_color, 0.0, 1.0);

	// This calculates how bright the secondary subpixels will need to be
	vec3 highlights = target_color - target_clamped;
	highlights /= 1.0 / mask.w - 1.0;

	target_clamped *= mask.rgb;

	// Add the secondary subpixels
	target_clamped += highlights * (1.0 - mask.rgb);
	
	// Blend with a dim version
	target_clamped = mix(linear_color * mask.rgb, target_clamped, brightness);

	return target_clamped;
}

void fragment()
{
	// Warp UV coordinates
	vec2 warped_coords = warp(UV, aspect, curve * 0.5);

	// Sample the scanlines
	vec3 col = scanlines(warped_coords);

	// Apply phosphor mask
	col = mask(col, FRAGCOORD.xy);

	// Convert back to srgb
	col = linear_to_srgb(col);
	
	COLOR.rgb = col;
}